"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/api-docs/docs/live-updates/channels/",title:"Channels",section:"Live Updates",content:` Channel Changes # Using graphQL subscriptions we can listen for changes to a channel without making repeated queries! Before starting this tutorial you should understand basic graphQL and have a method of authentication. Completing our websocket tutorial will also be helpful.
Need authentication? Start with access tokens
Websocket tutorial can be found here
Selecting a Channel # Before we can subscribe to a user we need a channel ID. This will specify which channel we are wanting to connect to. The easiest way to get a channel ID is to and make the following query. Simply replace YOURNAME with the channel you want to listen to.
query { channel(streamerUsername: \u0026#34;YOURNAME\u0026#34;) { id } } Glimesh will return a response that should look something like this.
{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34; } } } Building Our Subscription # Now that we have a channel ID we can build our subscription query. Glimesh will send us data through this subscription whenever a change is made to the selected channel. Our query needs to specify the information we want returned when this happens.
Note that any change to the channel will result in data being sent even if you did not listen for that specific change. The data received will contain the query and nothing more.
To keep things simple we will listen for a change in the channel title.
subscription { channel(id:6) { title } } Don\u0026rsquo;t forget to replace 6 with your channel ID!
If Glimesh detects a change in the channel it will send us the data that we asked for. As noted above any change will cause this data to be sent, not just a title change. Next we will create a connection to Glimesh and send them our subscription!
Websocket Connection # Since this is a subscription a websocket connection is needed. If you have followed the chat websocket tutorial you can modify that code to fit this tutorial. If you have not done so you must do the following -
Create a connection URL:
For Access Tokens: wss://glimesh.tv/api/graph/websocket?vsn=2.0.0\u0026amp;token=TOKEN_HERE
For Client IDs: wss://glimesh.tv/api/graph/websocket?vsn=2.0.0\u0026amp;client_id=CLIENT_ID
Make sure to replace TOKEN_HERE or CLIENT_ID with their proper values!
Open a connection and send this through:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}] Send this through replacing 6 with your channel ID. [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ channel(ID: 6) { title, id } }\u0026#34;,\u0026#34;variables\u0026#34;:{} }] Send this through every 30 seconds. [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;heartbeat\u0026#34;,{}] Having issues? The websocket tutorial goes into more detail about the connection. You may find it helpful to complete that tutorial first. If you are still having problems talk to us in discord.
The above code will connect to Glimesh, subscribe to any changes, and keep us from getting disconnected. To test our code we need to make a change on the channel that we specified. We requested to be sent the current title. Lets change it and see our code in action!
Before (Basic Query)
{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Hello Glimesh API \u0026#34; } } } After (Websocket)
[ null, null, \u0026#39;__absinthe__:doc:-576460752299317854:BEF9A4EF11FCFAD0A1B750BCEE8C2CBEAB66ADDAFE214A6CF692FBA68473F68A\u0026#39;, \u0026#39;subscription:data\u0026#39;, { result: { channel: { id: \u0026#39;6\u0026#39;, title: \u0026#39;Hello Glimesh API \u0026#39; } }, subscriptionId: \u0026#39;__absinthe__:doc:-576460752299317854:BEF9A4EF11FCFAD0A1B750BCEE8C2CBEAB66ADDAFE214A6CF692FBA68473F68A\u0026#39; } ] After the title was changed Glimesh sent us the new title. All properties will function the same way. Using this format you can listen to any property of any channel on Glimesh!
Looking for a reference? Click here to view all the channel properties.
If you have any questions talk to us in the #dev-questions channel in our Discord.
`}),e.add({id:1,href:"/api-docs/docs/chat/websockets/",title:"Connecting to Chat",section:"Chat",content:` Chat WebSockets # Glimesh uses WebSockets to allow for constant communication between you and the chat API. To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.
If you are testing you can use client credentials to get an access token. This will allow you to talk as your own account without going through the entire auth process.
Preparing the Connection # First, build your URL that you will connect to. It should look like this:
wss://glimesh.tv/api/graph/websocket?vsn=2.0.0\u0026amp;token=TOKEN_HERE That URL is for access token authentication. If you are using a client ID use this instead:
wss://glimesh.tv/api/graph/websocket?vsn=2.0.0\u0026amp;client_id=CLIENT_ID Make sure to replace TOKEN_HERE or CLIENT_ID with the proper token or ID.
Start by opening a secure websocket connection to the URL you are using. When the connection is opened we send Glimesh a join request in JSON format to stay connected to the socket. The array below is a example of what this should look like.
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}] Notice that this is a JSON array. Some WebSocket libraries only allow you to send strings or specially formatted JSON. Sometimes you need to encase the data in a string. If the connection closes immediately you may need to change the type of your request. This depends purely on your library, if you are having trouble talk to us in our discord.
Javascript example using the ws NPM package:
connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}]\u0026#39;); // Option 1 connection.send(JSON.stringify([\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}])); //Preferred option The first value is the join ref. The second is the normal ref. They can be useful for multi-connections but we will use the value of 1 for all refs in this doc. The third is the topic. The fourth is the event. The fifth is for a payload. Glimesh does not require a payload for this request so we can leave this blank {} .
If Glimesh successfully receives our request we will get a response similar to what we sent. Notice that the first two values are the same. The response tells us that Glimesh is ready.
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Joining Chat # Now that Glimesh has accepted our connection we can connect to a chat. You will need a channel ID for the channel you want to connect to. If you do not know the channel ID you can query the API for it. Simply replace Mytho with the proper user.
query { channel(streamerUsername: \u0026#34;Mytho\u0026#34;) { id } } Remember: Channel IDs and user IDs are different things. Everyone is a user but not everyone has a channel.
Once you have the ID we can join the chat. Send this through the connection:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ chatMessage(channelId: 6) { user { username avatar } message } }\u0026#34;,\u0026#34;variables\u0026#34;:{} }] Make sure to replace 6 with your channel ID! The query we just sent will determine what data is sent to us every time a chat message appears in chat. In this example we requested the message and the user who sent it. We ask for the username and avatar of the user in the user object.
To view a list of everything you can request check out voyager here
Glimesh will send us a response:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752303349214:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Staying Connected (heartbeat) # Now we are connected to chat! The only thing left to do is send a heartbeat to Glimesh so the connection won\u0026rsquo;t be closed. You need to send a heartbeat every 30 seconds. Structure it as follows:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;heartbeat\u0026#34;,{}] Glimesh will respond with:
[\u0026#34;null\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] Now Glimesh won\u0026rsquo;t disconnect us and we have a stable chat connection! Next we will parse incoming messages and send messages back to chat.
Incoming Messages # First let\u0026rsquo;s handle incoming messages. A chat message sent from the API would look like this:
[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] It is returning the data that we requested when we connected to this channel. The subscription ID helps you keep track of which channel the message is from. When you receive a message you need to parse the JSON data. Then you can get any of the data from the response.
The chat API is being worked on so the structure will likely change in a future update.
Sending Messages # Next we will send a message back to chat. We must use a mutation to do so. Send this to chat:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;mutation {createChatMessage(channelId:6, message: {message: \\\u0026#34;Hello There!\\\u0026#34;}) {message }}\u0026#34;,\u0026#34;variables\u0026#34;:{}}] Don\u0026rsquo;t forget to replace 6 with your channel ID and Hello World with your message! The \\ before the quotes are used to prevent the JSON structure from breaking. Depending on how your lib handles ws messages they may not be necessary. The format for sending messages is very strict, ensure Glimesh receives your data as valid JSON.
Only access tokens with the chat scope can talk in chat. Client IDs are read only. In the above data we requested to have the message returned to us when Glimesh sent it to chat. Glimesh will confirm that the message was received:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;createChatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;Hello There!\u0026#34;}}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] WebSocket API Queries # You don\u0026rsquo;t need to disconnect from the connection to make a normal API request. You can send requests from within your websocket connection! As with normal queries you are limited by the scope of your access token or client ID. Let\u0026rsquo;s build a simple request.
query { followers(streamerUsername: \u0026#34;CHANNEL\u0026#34;) { id, user { username } } } In this example we request the ID and username of the followers of a channel. Replace CHANNEL with any streamer on Glimesh. Keep in mind that they must be a channel and not just a normal user. Add this query as the payload in the message that we will send to the API. As with all requests we must make this valid JSON before sending it to Glimesh.
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;query {followers(streamerUsername: \\\u0026#34;CHANNEL\\\u0026#34;) {id,user {username}}}\u0026#34;}] This snippet is already JSON, you may have to make adjustments depending on your websocket library.
Glimesh will respond:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_reply\u0026#34;,{\u0026#34;response\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;followers\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;613\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;629\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;TheCat\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;752\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;Kirby\u0026#34;}},{\u0026#34;id\u0026#34;:\u0026#34;11992\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;RainbowFist\u0026#34;}}]}},\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;}] This is all the info you will need to connect and use the chat API. If you have any questions talk to us in our discord!
Connection Issues # The most common issue is the connection closing with no message as to why. One of two things has happened:
Heartbeat: You must send a heartbeat message to Glimesh every 30 seconds or Glimesh will drop the connection. Format: The chat API must receive data in the proper format. Most requests will need to be sent in a JSON array. The refs must be surrounded by quotes. The message in the mutation must also contain quotes. You may have to use a backslash to properly format the chat message. \\\u0026quot;message data\\\u0026quot; `}),e.add({id:2,href:"/api-docs/docs/live-updates/followers/",title:"Followers",section:"Live Updates",content:` Follower Alerts # This is a tutorial for follow alerts. This guide assumes you have a client ID or an access token from a user. You should also have a websocket connection open from this tutorial. Having basic GraphQL knowledge would also be helpful.
New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/
Building the Subscription # Follow alerts are made of a standard subscription. The streamer ID of the channel that you want to have alerts for is required. A streamer ID is equal to the user ID. You can acquire the ID with the below query.
query { user(username:\u0026#34;Mytho\u0026#34;) { id } } Make sure to replace Mytho with the channel name.
We will insert this ID into the below subscription. You must subscribe to this event through a websocket connection. Glimesh will notify us whenever a user follows the channel.
subscription { followers(streamerId:6) { hasLiveNotifications, id, insertedAt, streamer { username }, updatedAt, user { username } } } The above subscription shows all of the properties we can receive. This excludes nested properties. This information will be sent to us whenever the specified channel gets a new follower.
Need a tutorial for connecting to the API with websockets? Click here
Follower Query # A subscription is the standard way to get follower alerts. However, this is not the only method to get the followers of a channel. We can make a query to get the followers of a channel as well as the followers of a user. You will need the ID of the streamer or of the user. The following query will return the followers of a streamer.
streamerId is the user ID, not the channel ID.
Followers are paginated, see our guide on that here
query { followers(streamerId: 6) { edges { node { hasLiveNotifications id insertedAt streamer { username } updatedAt user { username } } } } } We requested the same properties as before. Glimesh will send us a JSON format response.
{ \u0026#34;data\u0026#34;: { \u0026#34;followers\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;node\u0026#34;: { \u0026#34;hasLiveNotifications\u0026#34;: false, \u0026#34;id\u0026#34;: \u0026#34;613\u0026#34;, \u0026#34;insertedAt\u0026#34;: \u0026#34;2020-08-09T15:14:21\u0026#34;, \u0026#34;streamer\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; }, \u0026#34;updatedAt\u0026#34;: \u0026#34;2020-08-09T15:14:21\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;hasLiveNotifications\u0026#34;: false, \u0026#34;id\u0026#34;: \u0026#34;629\u0026#34;, \u0026#34;insertedAt\u0026#34;: \u0026#34;2020-08-09T16:35:55\u0026#34;, \u0026#34;streamer\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; }, \u0026#34;updatedAt\u0026#34;: \u0026#34;2020-08-09T16:35:55\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;TheCat\u0026#34; } } }, and so on... We can also request who a user is following. The query is nearly identical. The only thing we change is the parameter. Replace streamerId with userId.
query { followers(userId: 6) { edges { node { hasLiveNotifications id insertedAt streamer { username } updatedAt user { username } } } } } Stuck with something? Talk to us in Discord. We would be happy to help you!
`}),e.add({id:3,href:"/api-docs/docs/chat/mutations/",title:"Sending Messages",section:"Chat",content:` Sending Messages # This tutorial will enable you to send and receive chat messages using the Glimesh API.
This tutorial is for the HTTP API. This is not a websocket tutorial. If you are looking to build a chatbot or other program that needs a constant connection view this tutorial.
To connect to a chat you will need an access token or a client ID. Keep in mind that using a client ID will keep you in read-only mode for chat environments. The access token must have the chat scope to post messages.
If you are testing you can use client credentials to get an access token. This will allow you to talk as your own account without going through the entire auth process.
Starting Up # Since we are not using a websocket connection we have to manually query and send chat messages. This is done through the Glimesh API. We can query any channel for chat messages. We can also send messages to any channel that we choose. Understanding how API requests work will be important for completing this tutorial.
New to the API? Read this before starting.
Authentication # All API requests must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:
Authorization: Bearer YOUR_TOKEN .
Replace YOUR_TOKEN with your access token. If you are using a client ID to authenticate you must use this instead:
Authorization: Client-ID YOUR_CLIENT_ID
Replace YOUR_CLIENT_ID with your ID. This will allow you access to the API.
A client ID can only use the API in read only mode. An access token must have the chat scope.
Querying Existing Messages # We need to set up a query to gather the chat messages. You will need the channel ID of a streamer to get the messages. You can get a channel ID with this query. Replace Mytho with the name of the user that you want the ID from.
query { channel(streamerUsername: \u0026#34;Mytho\u0026#34;) { id } } Once you have the ID we can build our request. The query needs to be in the body of the request. You must send the query as a POST request. Structure it as follows:
query { channel(id: ID) { chatMessages(last: 10) { edges { node { message, user { username, avatarUrl } } } } } } Don\u0026rsquo;t forget to replace ID with the channel ID! If you want more data you can view the chatMessage reference here Chat messages are paginated, you can read about that here
Glimesh will respond with a set of JSON data. You need to parse it to get the data that you want.
{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;chatMessages\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;node\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;lee run the free truck in ovals bro no chance of rating loss and really gives you a good feeling \u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/Sainted_Lord.png?v=63782488662\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Sainted_Lord\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;You all make this game seem so awesome! D:\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;avatarUrl\u0026#34;: \u0026#34;https://glimesh-user-assets.nyc3.cdn.digitaloceanspaces.com/uploads/avatars/FadedKamui.png?v=63794027172\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;FadedKamui\u0026#34; } } }, // and so on... Sending Messages # The Glimesh API uses mutations to send messages. The request must contain this mutation with a channel ID and a chat message. Structure it as show below. Make sure to replace MESSAGE with your chat message and ID with your channel ID.
mutation { createChatMessage(channelId:6, message: {message: \u0026#34;MESSAGE\u0026#34;}) { message, insertedAt, user { username } } } This should go in the body of the request.
Glimesh will return with the message that was sent to chat. If you want more data you have to request it. The chatMessage reference can be found here.
{ \u0026#34;data\u0026#34;: { \u0026#34;createChatMessage\u0026#34;: { \u0026#34;insertedAt\u0026#34;: \u0026#34;2021-01-08T05:03:44\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;MESSAGE\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;AFaithfulServant\u0026#34; } } } } This is all of the info required to interact with the chat API. Although this is a viable method, using websockets is the standard way of connecting to the chat. Websockets provide a constant connection and eliminates the need to query the API for new information. This is essential for services such as chatbots. If you have any questions talk to us in our discord.
`}),e.add({id:4,href:"/api-docs/docs/contributing/",title:"Contributing",section:"Docs",content:` Contributing # Thanks for wanting to contribute to the api-docs! We are grateful for your help.
Contributing to the API Docs. # Anyone can contribute to the docs. We only ask that you follow a few guidelines when contributing.
Follow the file structure. Each topic (or sub-topic) has language specific folders and a basic guide. Inside each language folder there should be a tutorial and a code file if applicable. You do not need to tackle an entire topic by yourself. Completing even one tutorial is helpful!
Follow the tutorial structure. Try to keep each tutorial as objective as possible. You can have some personal expression but try to keep it limited. We want these guides to be as short and as simple as they can get. The tutorial should be written in Markdown. Explain every step and clearly document any code used. Don\u0026rsquo;t do this.
Run any code through a prettier software. Try to keep the code looking nice! It doesn\u0026rsquo;t matter which formatter you use but we want the code to be readable.
Follow the Glimesh and Github TOS (Terms of Service). Any tutorial that violates either of the TOS will be removed. Any malicious code will be removed.
Process # Start by forking the repository. Access the fork on your PC or on https://github.com/YOURNAME/api-docs . You will want an environment capable of editing markdown (.md) files. Any IDE will do.
Stack Edit is a free markdown editor running in the browser. It is easy to use and has many tools for markdown formatting. You can copy the contents of the files there to edit them.
You will need to create your tutorial as described above. You will also need Hugo installed. Get the extended features edition.
This installation can be a bit complex for Windows users so you may want to follow a tutorial.
In the command line navigate to the folder containing your fork. Run hugo server --minify --theme book in your terminal. If you get a theme error you can run git clone https://github.com/alex-shpak/hugo-book themes/book or install the git submodules. It will install the necessary theme files. When it finishes installing run the server command again. This will open a server on http://localhost:1313/api-docs.
The server will restart when any changes are saved. Editing config or other important files will require a manual restart though.
You can add special markdown formatting if you want to. If you are making a new file Hugo will detect the it and update the menu on the left side of the page with your new file. The menu will alter itself to match the file directory. This may require a restart of the server for the menu to update.
Notice that every folder with content has a _index.md file. Create a new _index.md file and fill it with the info below if you created a new folder. This allows the tutorial to be collapsible in the menu. If the weight is the same they will be alphabetically sorted.
--- bookCollapseSection: true weight: 20 --- When you are satisfied with the look of your tutorial you can submit a PR. Close the server. Commit and push your changes. Create a pull request with a brief overview of your tutorial/topic. We may ask you to make changes. Once accepted we will add your tutorial to the repo and add it to the website.
Thank you for contributing!
`}),e.add({id:5,href:"/api-docs/docs/live-updates/subscribers/",title:"Subscribers",section:"Live Updates",content:` Subscriber Alerts # The Glimesh API does not have a live update event for channel subscribers. However, you can listen for the subscriber chatmessage to be notified when someone subscribes to a channel. This requires that you have a working websocket connection.
Listening for Subs # Simply ask Glimesh for the added property in a chatmessage subscription. This is a deprecated property and will be replaced in the future.
subscription{ chatMessage(channelId:1) { message, # True if new subscriber message isSubscriptionMessage, # True if new follower message isFollowedMessage, user { username }, } } `}),e.add({id:6,href:"/api-docs/docs/chat/chat-tokens/",title:"Tokens (Message Parts)",section:"Chat",content:` Chat Tokens # Chat tokens are a different way to handle messages sent from chat. A normal message is just a simple string. A chat token is an array of data that shows you all sorts of information about the message and what it contains.
This is a continuation of the websocket tutorial. If you have not already completed the tutorial you can do so here. A chat connection is required for this tutorial.
The Basics # A chat token is the original message split by several factors.
Normal text Emotes URL\u0026rsquo;s Using the token property we can identify information we would previously have had to parse. Normal text is exactly what is sounds like. Emotes are emotes from Glimesh. The URL is included as well as the text to create it :glimsmile: . URL\u0026rsquo;s are also detected separately from text. This information is also provided alongside the default message property. This means you don\u0026rsquo;t have to use chat tokens if you don\u0026rsquo;t want to.
As shown in the image above the chat parts contain all the data from the chat message. The original message is above the chat parts.
Building The Query/Subscription # We need to query chatMessage. We will plan for every possible type of data in a message. If you do not already have a working websocket for Glimesh you need to get one. If you don\u0026rsquo;t want to keep a connection open you can make a normal query to the channel and view the chatMessages property. Either method is valid.
Start with this subscription
subscription{ chatMessage(channelId:6) { message, user { id }, tokens { ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } Or use a query.
query { channel(id: 6) { chatMessages(last: 5) { edges { node { message user { id } tokens { ... on EmoteToken { src text type } ... on TextToken { text type } ... on UrlToken { text type url } } } } } } } Make sure to replace 6 with your channel ID!
You don\u0026rsquo;t need to request every property, adjust the request as needed.
These requests will return the chat message as well as its message parts. The parts are in an array. The array values are generated if the message contains the type requested. If the type does not exist an array value is not generated.
Example websocket response:
[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;message\u0026#34;:\u0026#34;Hello Glimesh Devs :glimsmile:\u0026#34;, \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://glimesh.tv/emotes/svg/glimsmile-af9a10c9d4c4181dbd87ab245d3e3bee.svg?vsn=d\u0026#34; } ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ] Message: Hello Glimesh Devs :glimsmile:
Your response will vary slightly depending on the message and the query.
FAQ # Q: What happens if I use a nonexistent emote? :fake_emote:
A: Glimesh will realize the emote is not real and detect it as text.
Q: What is the difference between this and the normal chat API?
A: This version is more advanced and all the parsing is done for you.
Q: Should I switch to chat parts?
A: That depends on your project. The normal chat API isn\u0026rsquo;t going away so you can use whichever method you like.
If you have more questions feel free to talk to us in our discord!
`}),e.add({id:7,href:"/api-docs/docs/chat/moderation/",title:"Moderation",section:"Chat",content:` Chat Moderation # Using the Glimesh API we can use mod features such as timeouts and bans. These are critical for chatbots and other services. Before starting this tutorial you should have a working connection to the API and understand basic GraphQL.
New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/
If you are looking for live updates related to moderation you can apply the queries in this tutorial to our Live Updates tutorial here.
Understanding Mod Actions # Glimesh has various methods to help streamers moderate their chat. All of the below methods are useable through the API.
Action Result banUser Bans the user from the channel. unbanUser Removes the ban on a user. longTimeoutUser Prevents a user from typing for 15 minutes. shortTimeoutUser Prevents a user from typing for 5 minutes. deleteChatMessage Removes a message from chat. To use any of these methods you must have the proper rank in the chat. You need to be a streamer or a moderator in their chat. You also need the user ID of the user who will receive the action and the channel ID of the channel in which the action will take place. You can get a channel ID with the below query.
query { channel(streamerUsername: \u0026#34;NAMEHERE\u0026#34;) { id } } A user ID can be attained from various queries. Since you are likely in a chat you can pull the ID from the chatMessage event. Your subscription to a chat (to listen for chat messages) would look something like this.
subscription { chatMessage(channelId:6) { message, user { id } } } The message would be the chat message and the ID in the user object would be the ID of the user who sent the message.
There is also an ID property in the chatMessage. This is the ID of the message, not a user or channel ID. Don\u0026rsquo;t get them confused!
Connection # Now that we have a method to get the user and channel IDs we can start banning everyone moderating!
Memes aside, you always need to use the API responsibly. Bots, AI, and message parsing can fail and you never want to wrongly ban a user. Always ensure that any automated services log all their actions. You may need to go back and unban someone if a mistake is made.
For testing purposes you should use your own channel and a bot account. You can ban yourself but it\u0026rsquo;s easier to use a different account. Glimesh uses mutations to moderate users. Mutations can be sent in http or websocket form. If you are in chat it is best to use the websocket since a connection would already be open.
Timeouts # Send this to the API to timeout a user for 5 minutes.
mutation { shortTimeoutUser(channelId:6, userId:201) { action, moderator {displayname}, } } You need to replace 6 and 201 with the proper IDs.
A long timeout is very similar. This will last for 15 minutes.
mutation { longTimeoutUser(channelId:6, userId:201) { action, moderator {displayname}, } } Bans # Banning users works the same way. Simply replace the timeout mutation with the ban mutation.
mutation { banUser(channelId:6, userId:201) { action, moderator {displayname} } } If you need to unban a user you can use this mutation.
mutation { unbanUser(channelId:6, userId:201) { action, moderator {displayname} } } Delete Messages # You can also delete messages. You need the channel ID and the message ID. The message ID can be attained by querying the messages in a channel or by requesting it in a chatMessage subscription. Use this mutation to delete a message.
mutation { deleteChatMessage(channelId:6, messageId: 111) { action, moderator { displayname } } } Attempting to unban a user that is not banned will return an internal server error. Attempting to use any moderator action on a user or message that does not exist will return \u0026ldquo;not found\u0026rdquo;. Using moderator actions in a channel that you do not have the authorization will result in an error. If you need more information about what properties you can receive from a moderator action check out the moderator reference. It provides a list of all the properties you can request. Glimesh.tv/api has a full list of all the API features.
Moderation Log # Glimesh stores a copy of all the moderation events that happen to a user. This log can be viewed by the streamer here. We can also access this log via the API. Unlike the webpage, this log can be viewed by any user! Let\u0026rsquo;s create a basic query.
query { channel(id:6) { moderationLogs(last: 3) { edges { node { action, moderator {username} } } } } } This will return an array of data showing the moderation logs. Moderation logs are paginated, you can read more about that here
{ \u0026#34;data\u0026#34;: { \u0026#34;channel\u0026#34;: { \u0026#34;moderationLogs\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;node\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;delete_message\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;delete_message\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;AFaithfulServant\u0026#34; } } }, { \u0026#34;node\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;delete_message\u0026#34;, \u0026#34;moderator\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } } ] } } } } That is the basis for using moderation actions with the API. All of the above queries and mutations can be done through a websocket connection as well as a normal query.
If you have any questions talk to us in the #dev-questions channel in our Discord.
`}),e.add({id:8,href:"/api-docs/docs/dev-app/",title:"Dev App",section:"Docs",content:` Developer Application # Although making an application is easy, developers new to OAuth may find some of it confusing. This tutorial will explain the basics of what information is asked for and what is it used for.
Ready to make your application? Start here
Name # The name of your project is a user friendly name for your application. Both Glimesh and your users will see this when they authenticate with your app.
Homepage # The homepage of your app is where your product (if applicable) is located. This could be a website for a chatbot, an online tool, or anything that uses the Glimesh API. You do not need to have a public domain to show your product if you don\u0026rsquo;t want to. Using a localhost URL is fine.
Description # The description is a basic explanation of your app. This should be a brief overview of what your app will be used for. Details, details, details!
Image # The image you choose here is shown to all users who authenticate with your app. It should be representative of your app and must not violate the Glimesh Terms of Service.
Allowed Redirect URIs # The redirect URIs are where Glimesh will redirect users of your app after they authenticate with your app. You specify which one to redirect to in the client request. You should have one URL per line. We prefer HTTPS over HTTP but using a locally hosted HTTP server will be fine.
A complete dev app will look like this when authenticating.
`}),e.add({id:9,href:"/api-docs/docs/live-updates/explanation/",title:"Live Updates Explained",section:"Live Updates",content:` Live Updates # Live updates allow you to listen for changes through the API. Glimesh will notify you when a requested event occurs.
Live updates are sent via a websocket connection. You can set that up here.
Types of Events # There are 3 events you can subscribe to. Each works the same way.
Channels # Channel events occur when a top level field changes. You can listen for the status (live/not-live), title, and any other information. Note that you can only request top level properties.
subscription { channel(id: 1) { status title # Any other fields you want... streamer { id # Will not work since it is a nested field } } } Followers # Follower events occur when a user follows a channel. You can request info about the channel and the user who followed the stream.
subscription { # streamerId is the userId followers(streamerId: 6) { hasLiveNotifications id insertedAt streamer { # streamer info username } updatedAt user { # user info username } } } ChatMessages # Chatmessage events occur when a message is sent to a specified chat. We have a dedicated tutorial for this here.
Subscribers # You can listen for new subscribers. However, you cannot do so via the live updates. View this page for more information.
`}),e.add({id:10,href:"/api-docs/docs/authentication/accesstoken/clientcredentials/",title:"Client Credentials",section:"Access Token",content:` Client Credentials (Access Token) # An access token can be used to query the Glimesh API on behalf of a user. Normally you have to get a token from a user. Client credentials allows us to generate an access token for our own account to act as an authenticated user. This is frequently used for testing purposes.
Requesting A Token # Before requesting a token you must have a developer application. You will need your client ID and secret key.
Simply make a POST request to the following URL replacing CLIENT_ID and SECRET_KEY with the info from your dev app.
https://glimesh.tv/api/oauth/token?grant_type=client_credentials\u0026amp;client_id=CLIENT_ID\u0026amp;client_secret=SECRET_KEY Glimesh will respond with:
{ \u0026#34;access_token\u0026#34;: \u0026#34;qwertyuiop1234567890\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2021-03-21T19:32:21\u0026#34;, \u0026#34;expires_in\u0026#34;: 21600, \u0026#34;refresh_token\u0026#34;: null, \u0026#34;scope\u0026#34;: \u0026#34;public\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34; } The access token received will allow us to make requests as if we were using a normal access token. We have permissions for all the scopes and have access to any user specific properties. The token generated will expire in 24 hours just like a normal token. Unlike normal tokens, this cannot be refreshed. As with all auth information you must keep this private.
If you don\u0026rsquo;t request any scopes you automatically have access to every scope. If you do request a scope you only have access to the scopes that you requested.
If you have any questions talk to us in the #dev-questions channel in our Discord.
`}),e.add({id:11,href:"/api-docs/docs/authentication/accesstoken/pkceauth/",title:"PKCE",section:"Access Token",content:` PKCE Authentication Flow # PKCE builds upon authorization flow. PKCE is commonly used for mobile and frontend code where your source code (namely client ID) is accessible to your users. PKCE auth does not require a client secret.
Glimesh closely follows the RFC spec which can be found here.
Verifier and Challenge # First we need to generate a code verifier and a code challenge to use in the authorization request.
A code verifier is a random string using unreserved characters that is 43-128 characters long. The RFC acceptable characters are listed below.
code-verifier = 43*128unreserved unreserved = ALPHA / DIGIT / \u0026#34;-\u0026#34; / \u0026#34;.\u0026#34; / \u0026#34;_\u0026#34; / \u0026#34;~\u0026#34; ALPHA = %x41-5A / %x61-7A DIGIT = %x30-39 You can generate the verifier in whichever method is the most convenient for your application. There is a great set of code samples to generate the code verifier. Below is their example for javascript.
function dec2hex(dec) { return (\u0026#39;0\u0026#39; + dec.toString(16)).substr(-2) } function generateRandomString() { let array = new Uint32Array(56/2); window.crypto.getRandomValues(array); return Array.from(array, dec2hex).join(\u0026#39;\u0026#39;); } let verifier = generateRandomString(); Next we need to create a code challenge. We use the verifier to create the challenge. Glimesh requires us to use the S256 transformation as specified in the RFC spec.
code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))
As before we will use the code samples to generate our example. Their javascript example is listed below.
function sha256(plain) { // returns promise ArrayBuffer const encoder = new TextEncoder(); const data = encoder.encode(plain); return window.crypto.subtle.digest(\u0026#39;SHA-256\u0026#39;, data); } function base64urlencode(a) { let str = \u0026#34;\u0026#34;; let bytes = new Uint8Array(a); let len = bytes.byteLength; for (let i = 0; i \u0026lt; len; i++) { str += String.fromCharCode(bytes[i]); } return btoa(str) .replace(/\\+/g, \u0026#34;-\u0026#34;) .replace(/\\//g, \u0026#34;_\u0026#34;) .replace(/=+$/, \u0026#34;\u0026#34;); } async function challenge_from_verifier(v) { hashed = await sha256(v); base64encoded = base64urlencode(hashed); return base64encoded; } let challenge = await challenge_from_verifier(verifier); Now we need to get permission from the user.
You should create a new verifier and challenge for each user. They should be kept private, and deleted when the user is authenticated.
Authorization Code # Now that we have our code verifier and code challenge we can direct our user to Glimesh so they can approve our app. You will need a client ID handy.
Need a client ID? Create a dev app here.
The user must be directed to the authorization URL with the below query parameters.
https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;code_challenge=CODE_CHALLENGE\u0026amp;code_challenge_method=S256\u0026amp;client_id=YOUR_CLIENT_ID\u0026amp;redirect_uri=YOUR_CALLBACK_URL\u0026amp;scope=SCOPE Make sure to replace the parameters with their values. When the user is directed to Glimesh they will be asked to approve the scopes you requested. If they approve it they will be redirected to the redirect URL provided. We need to extract the authorization code from the URL (sent as a query param). There are many libraries for each language to help with this. Since we are just testing we can look at the URL and copy it manually.
http://localhost:3000/success?code=qwertyuiop1234567890 Example redirect URL response. We want the code value.
This code expires in 60 seconds. If it expires you have to get the user to authorize your app again.
Getting Tokens # Now that we have an authorization code we can request an access token. Simply send a HTTP POST request to the below URL adding the body as x-www-form-urlencoded.
https://glimesh.tv/api/oauth/token code_verifier:Verifier Here client_id: Client ID Here redirect_uri: Redirect Uri Here scope:public code:Authorization Code Here grant_type:authorization_code Each line is one key/value.
When Glimesh receives your request they will send back an access and refresh token, as well as other info about the request.
{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } Glimesh will send an error in JSON format if your request has an error. Keep in mind that all credentials must be accurate and you must request a token within 1 minute of the user authorizing your app. You need to include the code verifier, not the challenge!
You can use the access token for 24 hours. When it expires you need to request a new one with your refresh token. We have a guide on refreshing tokens which can be found here.
Questions? Join the #dev-questions channel on our discord.
`}),e.add({id:12,href:"/api-docs/docs/api/api-explorer/",title:"API Explorer",section:"API",content:` API Explorer # Insomnia is a GraphQL explorer. It allows you to make queries without needing a dev environment. It is the recommended way to learn the API and is helpful if you are new to programming.
We have a JSON file with a collection to handle auth and make common requests in Insomnia. You can download it here
Getting Started # First we need to download Insomnia. They have a free tier which is more than enough for our purposes. Insomnia can be downloaded here. You don\u0026rsquo;t need to make an account to use the app. When the download is complete, you can skip your way through setup and get to the collection viewer.
Glimesh Collection # If you downloaded the Glimesh Collection this will be a very fast setup. Drag the file directly into the editor. This will import all our requests and our environment variables.
First we need to set up our variables to authenticate our requests. On the top left select the \u0026ldquo;no environment\u0026rdquo; button. Then \u0026ldquo;manage environments\u0026rdquo; . Add your client ID / secret to their matching values. If you do not yet have an ID you can get one by creating a dev app.
Insomnia will automatically run the auth request now that the variables are filled in.
The file contains a few common requests. To test one, click on the request. Then select the send button. Your response will appear on the right.
All the requests in this file have the auth header. If you make a new request you will have to add it yourself. Simply have the header name as \u0026ldquo;Authorization\u0026rdquo; and the value as the access_token environment variable (ctrl+space in the text field to view env variables). You can use the default_url variable for the URL.
Manual Setup # Create a new collection. For this tutorial we will call this collection \u0026ldquo;Glimesh\u0026rdquo;.
First we will handle authentication. Generally it\u0026rsquo;s easiest to make 1 auth request and have your credentials be environment variables. We will start with the variables first. On the top left press environment. Then manage environments. Copy the below JSON into the box.
{ \u0026#34;base_url\u0026#34;: \u0026#34;https://glimesh.tv/api/graph\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;YOUR_ID_HERE\u0026#34;, \u0026#34;client_secret\u0026#34;: \u0026#34;YOUR_SECRET_HERE\u0026#34;, \u0026#34;access_token\u0026#34;: \u0026#34;Bearer \u0026#34; } Copy your ID/secret into their places. For the access token we need to make a request that will authenticate you. Close the environments box.
Create a new request on the left. Use https://glimesh.tv/api/oauth/token for the URL. It needs to be a POST request with a multipart-form body. Title the request Auth.
Use the following values for the form entries.
The purple boxes are the variables from earlier. Press ctrl+space while in the text field to view all variables and select the proper variables. To verify that the request is valid send the request. You should receive an access token from the response. If you don\u0026rsquo;t receive one make sure all the values are correct.
Note that I have 5 headers, you will not have that many for this request. The default Insomnia headers will suffice.
Next we need to set our access token to the access_token variable in Insomnia. Open the environment tab from earlier. In the access token value after Bearer press ctrl+space. Select response =\u0026gt; body-attribute. Click on the box that appeared in the value.
Request must be set to out Auth Request from eariler. Filter must be $.access_token . This pulls the token from the auth response. The trigger behavior must be set to \u0026ldquo;when expired\u0026rdquo;. Max age is 21600 (the life of the token). Select done. Close the variable window.
Now we can make a request to get data from the API. Create a new request. You can use the base_url variable or enter the URL manually.
https://glimesh.tv/api/graph
It needs to be a POST request and have a body type of graphql. We need to add our auth info from the previous request. Head to the header section. The name needs to be \u0026ldquo;Authorization\u0026rdquo; and the value needs to be your access_token variable.
Now we can head back to the GraphQL section. You can make any query but we will request the user ID from a user. Copy the below query into the section.
query { user(username: \u0026#34;Mytho\u0026#34;) { id } } All that\u0026rsquo;s left is to make the request! Select send on the top and the result will be on the right. You can make any number of requests in this format. The Glimesh collection includes basic requests and can be downloaded here
Generating Code # Insomnia can generate code based on your request to the API. Although the code will work, it could likely use some optimizing based on your needs. Insomnia supports most programming languages, so choose the one that matches your project. Right click on a request and select generate code.
This will open a box and you can choose the format and language. If you have any questions about using the Glimesh collection or using the Glimesh API let us know in #dev-questions in our discord.
`}),e.add({id:13,href:"/api-docs/docs/api/migration/",title:"Migration",section:"API",content:` API Migration # Glimesh has started migrated to a new API because of major changes in the way result data is returned from the API. We\u0026rsquo;ve added pagination to all queries that return lists to improve performance on the app, and renamed several fields for consistency.
In addition, we are in the process of migrating to a new OAuth 2.0 provider which adds additional features, but may require some changes for your application. The migration to the new OAuth 2.0 provider will complete on August 20th 2021 at 8AM EDT.
If you are new to the API you can safely skip this doc.
Timeline # The new API endpoint has already been introduced, however there are currently no plans to remove the old API endpoint. However we will be soon pointing all new developers to our new API only, and removing documentation relating to the older API as we continue to prove the new one out.
Using the New API # Using the new API is very easy. Simply point all requests to the new URL.
HTTP Endpoint: https://glimesh.tv/api/graph WebSocket Endpoint: wss://glimesh.tv/api/graph/websocket This will give you full access to the new endpoints and features of the API.
What Changed? # Some changes are internal and do not affect the developer. However, the following changes will affect you:
The new API endpoint does not support a built-in graphical editor. This change was required to properly support CORS across the new API endpoint. We have a new tutorial about using your own editor here. Query Complexity analysis has been added which will help us maintain API performance. You should not run into any limits with any possible queries (due to pagination), but if you do receive errors about query complexity, let us know so we can check it out! The following fields have been added to the API. Category insertedAt: Creation time of the category. updatedAt: When the category was last updated. Channel chatBgUrl : The URL of the channels chat background. posterUrl: Image that is shown in place of the stream when the user is offline. Streams: List of the streams the channel currently has (1). See pagination. Channel Ban id: The ID of the channel ban. Channel Moderator id: The ID of the channel moderator. Stream thumbnailUrl: The URL of the current thumbnail (stream snapshot) User allowGlimeshNewsletter: Does the user allow newsletters? allowLiveSubscriptionEmails: Does the user allow \u0026ldquo;going live\u0026rdquo; emails? channel: The user\u0026rsquo;s channel. email: The user\u0026rsquo;s email address (scope protected). followingLiveChannels: The channels that the user is following that are currently streaming. insertedAt: When the user was inserted into the database. showOnHomePage: Has the user enabled the selection to be on the homepage? teamRole: The role the user has on the Glimesh Team (dev, design, GCT, etc) updatedAt: The last time the user was modified. The following are now paginated and no longer return every item in the collection at once. See pagination Subcategories Tags Channels Channel Bans Channel Chat Messages Channel Moderation Logs Channel Streams Channel Moderator List Followers Users User Followers User Following User Following Live Channels The following fields have been removed from the API. Some have been moved or had their names changed to a new field. Channel thumbnail: Moved to Stream as thumbnailUrl Replaced hmackey and username as arguments. Added streamerId and streamerUsername deleteMessage Changed to deleteChatMessage Emote Token url: Use src instead. Followers Replaced streamerUsername and userUsername as arguments. Added streamerId and userId Stream avgChatters avgViewers countChatters newSubscribers resubSubscribers subcategory: Moved to Channel. thumbnail: Changed to thumbnailUrl. User avatar: Use avatarUrl instead. Using the New Authentication # The new authentication method will not require any changes for the user. However, it does add support for PKCE auth.
What Changed? # Credentials now use new formats. Client IDs and Secret Keys will be converted for each request you make. This means you do not need to change your keys. However, we recommend that you migrate to the new format whenever possible. Simply rotate the existing keys from the dev app and replace them in your projects.
Access/Refresh Tokens Can now contain upper case values. Max length increased to 255 characters. Client ID Are now UUIDs instead of alpha-numeric values. Client Secret Can now contain upper case values. Max length increased to 255 characters. Our OAuth system now supports PKCE auth. This is a new standard and it is not required to use the API. We have a guide on it here.
`}),e.add({id:14,href:"/api-docs/docs/api/pagination/",title:"Pagination",section:"API",content:` API Pagination # Some fields in the API are paginated. We have to sort through the pages to get the data we requested. Glimesh follows the GraphQL pagination spec.
GraphQL pagination can be found here
Connection, Edges, and Nodes # Pagination is used when the data requested is too large to send to the user. Take the below query as an example. This query would return the ID of all the users on the site. This would take a long time for Glimesh to get the data and would be a large payload to send.
query { users { id } } # Above query will not work :( Instead of sending all the users, Glimesh sends us a UserConnection. This contains data on how to get the data we requested.
Note that each paginated field has its own Connection type. They always correspond to the field requested. Since we queried users we received a UserConnection
Connections # Connections contain a count of all the edges, the edges themselves, and a pageInfo. They help us get the data we requested, and show us how much data we can paginate through.
users { count, # How many edges exist on this query edges {}, # Some edges that match the query pageInfo {} # pageInfo containing info on the page returned } The count returns how many edges exist based on your query. This does not return the total amount of edges. For example, if you ask for the first 5 results you will have a count of 5, even though the total amount of edges is far more.
Edges # Each edge contains a cursor and a node. The cursor is a string of text that identifies the edge. The node is the data on that edge. Each node has 1 item we queried (in this case a user).
edges { cursor,# Unique ID that identifies the node node {id, username} # The node contains data that we requested } PageInfo # A PageInfo object exists on every connection. They contain an end and start cursor, as well as a hasNextPage and hasPreviousPage. Pageinfo can be used to determine if there is any more data to paginate through.
Note that the next and previous are determined by the first item returned, not the last.
pageInfo { endCursor, # ID of the last cursor for the connection hasNextPage, # bool hasPreviousPage, # bool, startCursor # ID of the first cursor for the collection } Paginating Through Data # Now that we know how pagination works, let\u0026rsquo;s get the 5 most recent users and the first 5 users on Glimesh. All the necessary queries are posted below, but you will need to run them in your own project or use a graphql explorer.
First we start by making a query to get the first 5 users. We can query more at a time, but for this tutorial 5 will suffice. We also ask for the cursor of each edge.
Request query { users(first: 5) { edges { cursor node { id username } } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjA=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;clone1018\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjE=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;IKAROS\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjI=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Kristoff\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjM=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Ember\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQ=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Heiwa\u0026#34; } } ] } } } Now we have the first 5 users. Since we also have the cursors of each edge we could query the next 5. Take the below query as an example. We still ask for the first 5 but we request it after the 5th edge from the last query.
Request query { users(first: 5, after: \u0026#34;YXJyYXljb25uZWN0aW9uOjQ=\u0026#34; ) { edges { cursor node { id username } } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjU=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Bubdrum\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjY=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Deicefenrir\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjc=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Umbreo\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjg=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;UnTubular\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjk=\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Asterisk\u0026#34; } } ] } } } Now we have the next 5 users. You can use this to move through the entire database. However, we wanted the last 5 users. We could continue in this way (although we would query more than 5 at a time!) but there is an easier way. We can use the last parameter. Simply replace first with last from the first query.
Request query { users(last: 5) { edges { cursor node { id username } } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc1\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42336\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Emad\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc2\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42337\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mr_Emotional\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc3\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42338\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;BruteMouse\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc4\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42339\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Bruhh\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc5\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42340\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;VeganGaymer\u0026#34; } } ] } } } This will return the 5 most recent users. Glimesh adds users in the order that they were created, so these users have the highest user IDs.
Note that you will get a different result. Users have been added since this doc was written, so you will get different users.
We can also request pageInfo with each paginated query. This will tell us if there is another page after or before our result, and show us the first and last cursor of our result. For our queries this wasn\u0026rsquo;t neccassary, but if you plan to paginate through a large amount of users it is very helpful. The below query gets 5 users before the last 5 users with the before parameter.
Request query { users(last: 5, before: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc1\u0026#34;) { edges { cursor node { id username } }, pageInfo { endCursor, # ID of the last cursor for the result hasNextPage, # bool hasPreviousPage, # bool, startCursor # ID of the first cursor for the result } } } Result { \u0026#34;data\u0026#34;: { \u0026#34;users\u0026#34;: { \u0026#34;edges\u0026#34;: [ { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcw\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42331\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;FsnGaming\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcx\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42332\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;ajsdlasdasd\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcy\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42333\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;dfhdhsad\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcz\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42334\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;dqbyudvbqhdbvzh\u0026#34; } }, { \u0026#34;cursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc0\u0026#34;, \u0026#34;node\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;42335\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Elitex\u0026#34; } } ], \u0026#34;pageInfo\u0026#34;: { \u0026#34;endCursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDc0\u0026#34;, \u0026#34;hasNextPage\u0026#34;: true, \u0026#34;hasPreviousPage\u0026#34;: true, \u0026#34;startCursor\u0026#34;: \u0026#34;YXJyYXljb25uZWN0aW9uOjQyMDcw\u0026#34; } } } } The same process applies for all paginated fields. If you have any questions be sure to let us know in discord!
`}),e.add({id:15,href:"/api-docs/docs/api/voyager/",title:"Voyager",section:"API",content:`Voyager is an interactive GraphQL API explorer. It allows you to view all the data in our API. Click and drag to move around the explorer. Click on a field to view its properties. Scoll to adjust zoom.
Loading... `}),e.add({id:16,href:"/api-docs/docs/authentication/accesstoken/accesstoken/",title:"Access Token",section:"Access Token",content:` Access Tokens # An access token can be used to query the Glimesh API on behalf of a user. You can also get info about the user that the token belongs to.
This guide is for getting a token from a real user. If you are just testing or don\u0026rsquo;t want to setup authentication yet you can use client credentials
Requesting A Token # Before requesting a token you must have a developer application. You will need your client ID, secret ID, and redirect URL. First you need to have a user authenticate with your app. The user must be directed to
https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=CLIENT_ID\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=REDIRECT_URL Make sure to replace your client ID and your redirect URL. The redirect URL must match one of the URL\u0026rsquo;s on your application. Scopes are space separated values that determine what permissions you want from the user. Only request the scopes that you need.
The current scopes are:
public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. streamkey View the streamkey of the user. (This is a protected field. Even with the scope it is unable to be accessed by third party devs.) follow Follow and unfollow on behalf of the user. stream_info Change the title on behalf of the channel. (Will be expanded to cover more fields) When the user is sent to the link they will have to accept your app scopes. They will then be sent to your apps redirect URL. Glimesh will send a code inside the URL when they are sent back to your app. You need to extract it from the URL.
http://your-app.com/some/area?code=qwertyuiop123 Once you have the code you need to make a request to Glimesh. We will exchange the code for an access token.
POST https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=CODE\u0026amp;redirect_uri=REDIRECT_URL\u0026amp;client_id=CLIENTID\u0026amp;client_secret=SECRETID Send a POST request with the URL above replacing the code,redirect url, client ID, and secret ID. Remember to keep the secret ID hidden from your users. When Glimesh receives the POST request it will send back the information we want. Once it is parsed it will look like this:
{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } Now you can query the Glimesh API on behalf of a user. This token will expire in 24 hours so you need to refresh it or ask the user for a new one. If you have any questions talk to us in the #dev-questions channel in our Discord.
Ready to refresh your token? Continue with OAuth here
Common Errors # There are a few errors you may encounter while requesting a token.
{ error: \u0026#39;invalid_grant\u0026#39;, error_description: \u0026#39;The provided authorization grant is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client.\u0026#39; } This means something is wrong with your URL. You can only use each code once. You must send the request with the grant_type=authorization_code for Glimesh to send you the access token. Ensure all of the data in the URL matches the data in your dev application. Glimesh will refuse any request that is not properly formatted.
{ error: \u0026#39;invalid_request\u0026#39;, error_description: \u0026#39;The request is missing a required parameter, includes an unsupported parameter value, or is otherwise malformed.\u0026#39; } This is a request error. Some part of your URL is not necessary or missing. Ensure the parameters in the URL are spelled correctly. You should also check that you have all of the required data in the URL.
Error: 401 Unauthorized. You must be logged in to access the API.
This is an authentication issue. This is commonly seen when querying the API but I added it here because it most likely means you must request another token. You must renew or request a new token and send the API request to Glimesh properly. Tokens expire daily unless they are renewed.
Stuck with something? Talk to us in Discord. We would be happy to help you!
`}),e.add({id:17,href:"/api-docs/docs/authentication/auth-explained/",title:"Auth Explained",section:"Authentication",content:` Authentication Explanation # Glimesh requires a form of authentication to use the API. Every query (or endpoint) must have authentication passed to it to receive your information. This doc explains what methods of authentication exist and how to get them.
Glimesh follows the OAuth 2.0 spec which can be found here
Methods of Authentication # If you want to use the API you must have a developer application. This is a small document that contains info about your product. Each project needs its own app.
The developer application will give you a client ID and a client secret. These are similar to passwords and should be kept private (In some cases the client ID must be public, see PKCE). This doc goes in-depth explaining the creation process.
There are two forms of authentication to use the Glimesh API. Both require you to create a developer application.
Client IDs # A client ID is the easiest way to get started with the API. Simply attach the below snippet as a HTTP header/value.
Authorization: Client-Id YOUR-ID This lets you query most fields and is a great starting point. There are a few limits when using client IDs:
You are not a user. You can\u0026rsquo;t use the myself query. You do not have any scopes so you cannot access scope protected fields (email, streamkey, etc) You are in read-only mode. You cannot use mutations (talking to chat, banning users, etc). Access Tokens # Access tokens represent a users consent to use the API on their behalf. You can access all of the API that you had access to with a client ID, and you can access what is granted in the tokens scopes. Attatch the below snippet as a HTTP header/value.
Authorization: Bearer YOUR_TOKEN Access tokens have the below limits:
Limited by your scopes. Expire in a short period (check the expires_in when you receive a token, usually 24 hours) Obtaining Tokens # There are a variety of methods (called flows) to get access tokens. DIfferent methods are better for different applications.
Client Credentials # This method is mainly used for testing the API. This will give you a token with all of the available scopes.
Client credentials require both a client ID and a client secret to obtain a token. They are used on the server side if you use 1 token for all of your requests. This method cannot be used when your source code is exposed to your users.
Tutorial
Authorization Code # This method is commonly used for authenticating users when you can hide authentication behind a server. This will give you a token based on the scopes you requested. You will need an authentication server. A NodeJS example can be found here
This flow requires a client ID and a client secret. As such this flow cannot be used if your users have access to your authentication code.
Tutorial
PKCE # PKCE (proof key for code exchange) is a new flow for obtaining a users access token. This requires a client ID as well as a user generated code_verifer and code_challenge.
PKCE is used when your source code is open to your users. This is one flow where your client ID can be safely shown to your users. No secret is required.
Tutorial
Refreshing Tokens # All access tokens expire after a short time. You can ask the user to authorize again and get a new token, or you can refresh the token. Each flow has a slightly different requirement for refreshing tokens.
Client credentials cannot be refreshed. You have to request a new token.
Authorization Code =\u0026gt; Follow normal refresh flow here.
PKCE =\u0026gt; We don\u0026rsquo;t have a doc for this yet, but you can follow the OAuth spec.
FAQ # Question: Do I still need a dev app if I am only testing/learning the API?
Answer: Yes, you need it for authentication.
Question: Why does Glimesh need the info requested on the dev app?
Answer: Glimesh will use it to contact you if your app is disrupting the API. All of the information is kept private.
Question: Do I need a website for the developer application?
Answer: No. You can use a localhost URL instead. ex. http://localhost
Question: Why doesn\u0026rsquo;t x work? I need help with \u0026hellip;.
Answer: Join our discord and ask your questions in the #dev-questions channel.
`}),e.add({id:18,href:"/api-docs/docs/authentication/refreshtoken/refreshtoken/",title:"Refresh Token",section:"Refresh Token",content:` Refresh Tokens # A refresh token allows you to get a new access token without having your user authenticate again. It is a standard part of OAuth 2.
Looking for authentication flow? Start with access tokens
Refreshing A Token # Refresh tokens are sent when you request an access token. You can pull them from the data that Glimesh sends you.
{ access_token: \u0026#39;qwertyuiopo1234567890\u0026#39;, created_at: \u0026#39;2020-12-14T15:15:29\u0026#39;, expires_in: 21600, refresh_token: \u0026#39;qwertyuiop0987654321\u0026#39;, scope: \u0026#39;public email chat streamkey\u0026#39;, token_type: \u0026#39;bearer\u0026#39; } You can refresh a token at any time. You do not need to wait for the access token to expire. Refresh tokens last for 1 month. When you refresh a token you will need all the info from when you requested an access token.
Send a POST request to below URL depending on your authentication type:
Authorization flow
https://glimesh.tv/api/oauth/token?grant_type=refresh_token\u0026amp;refresh_token=REFRESH_TOKEN\u0026amp;redirect_uri=REDIRECT_URL\u0026amp; client_id=CLIENT_ID\u0026amp;client_secret=SECRET_ID PKCE Auth
https://glimesh.tv/api/oauth/token?grant_type=refresh_token\u0026amp;refresh_token=REFRESH_TOKEN\u0026amp;client_id=CLIENT_ID\u0026amp;redirect_url=REDIRECT_URL Make sure to replace REFRESH_TOKEN, REDIRECT_URL, CLIENT_ID, and SECRET_ID with their corresponding values. They must match the values that were sent when you requested an access token. If you want new scopes you must request a new token.
Provided you formatted your request correctly Glimesh will send you back a new refresh token and access token.
{ \u0026#34;access_token\u0026#34;: \u0026#34;qwertyuioip123456789\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2020-12-21T23:08:22\u0026#34;, \u0026#34;expires_in\u0026#34;: 21600, \u0026#34;refresh_token\u0026#34;: \u0026#34;qwertyuiop098765321\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;public email chat streamkey\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34; } This will allow you to use the new token and continue to query the Glimesh API. You must use the new access token and the new refresh token. You can safely discard the old tokens.
Other Info # You cannot get new scopes from refresh tokens. You must make the user authenticate again with the new scopes. Access tokens last for 24 hours. You can refresh them earlier if needed. Refresh tokens last for 30 days. If a user revokes your dev app you cannot use the access or refresh tokens. This would require the user to authenticate again. If you have any questions talk to us in the #dev-questions channel in our Discord.
`}),e.add({id:19,href:"/api-docs/docs/chat/projects/sitewidesubscription/",title:"Site Wide Subscription",section:"Projects",content:` Site Wide Chat Messages # The Glimesh API allows you to subscribe to any channel to listen for chat messages. There is no limit to the amount of channels that you can listen to. In this project we will listen for every chat message from every user across the entire site.
Before starting you should fully understand the WebSocket Tutorial.
Starting Up # First we need to open a websocket connection to Glimesh. Use the process from the websocket tutorial linked above to get the connection open. Instead of subscribing to a specific channel you want to subscribe to the chatMessage event. You can do so with this:
[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ chatMessage { user { username avatarUrl } message } }\u0026#34;}] Normally the event requires a channel ID as a parameter. Since we don\u0026rsquo;t specify which channel to listen to it connects to every channel on the site. All you have to do is log the messages as they come in!
[null,null,\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;,\u0026#34;subscription:data\u0026#34;,{\u0026#34;result\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;chatMessage\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;hello world!\u0026#34;,\u0026#34;user\u0026#34;:{\u0026#34;avatar\u0026#34;:\u0026#34;/uploads/avatars/Mytho.png?v=63762672056\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;Mytho\u0026#34;}}}},\u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752298178591:33B2AA3BF7B8F0E158810EF0E0166F5E05840BE57444C92365C921943942A47D\u0026#34;}] Requesting More Data # In the example above we requested the message as well as the username and avatar of the chatter. This query shows all of the possible data we can get from a chat message.
subscription { chatMessage { id, insertedAt, message, updatedAt, isSubscriptionMessage, isFollowedMessage, channel { # Channel data }, user { # User data }, tokens { text, type, ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } This is all of the info required to listen to every chatroom. If you have any questions talk to us on our Discord.
`}),e.add({id:20,href:"/api-docs/docs/chat/projects/typescriptchatbot/",title:"Typescript Chatbot",section:"Projects",content:` Creating a Chatbot with Typescript # This tutorial will show how to make a basic chatbot for Glimesh. You should have some experience in Javascript or Typescript. This tutorial is focused towards beginners so as long as you have some programming experience you will be alright. You will need the below items.
NodeJS (Recent version, 12+) Code Editor (VSCode works great with this project) Glimesh account with a channel and a Dev App The finished project can be found on Github here. We suggest that you follow along and use it as a point of reference only if needed.
Note that if future tutorials are created the repo may look different. You can always go back to the commit for each tutorial. This one is called \u0026ldquo;Getting Started\u0026rdquo;.
If you have any questions let us know in the #dev-questions channel in Discord.
Getting started # First we will create the package.json file for our chatbot. This file contains info about our project and our dependencies. In a new folder run the below command in your terminal.
npm init -y
This will create a basic package.json file as seen below.
Your file will look slightly different depending on the projects git status and info entered (if -y is removed).
{ \u0026#34;name\u0026#34;: \u0026#34;glimesh-chatbot\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Tutorial for creating a chatbot on Glimesh.tv\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, }, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;git+https://github.com/aMytho/Glimesh-Chatbot.git\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;Mytho\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;bugs\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/aMytho/Glimesh-Chatbot/issues\u0026#34; }, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/aMytho/Glimesh-Chatbot#readme\u0026#34;, } Now we can begin installing the required dependencies. Type the below commands into your terminal.
npm install ws
npm install --save-dev typescript @types/ws
ws is a websocket client and server library. @types/ws is the type definitions for the websocket library. Typescript is the language we will be using.
Let\u0026rsquo;s create our first typescript file for the project. Create a index.tsfile in the root directory of the project. Add the below line into the file.
/* index.ts */ console.log(\u0026#34;Hello World\u0026#34;); Don\u0026rsquo;t copy the /* index.ts */ part. That is just to show which file the code belongs in! This will be applied to all files in this tutorial.
Now we need to run this file. Typescript files cannot be run natively. They need to be compiled to javascript. We will set up a tsconfig file to handle this for us. Create a file with the name tsconfig.json . Paste the below code into it. This sets the basic typescript options and tells the compiler which files and folders to compile.
We don\u0026rsquo;t have the lib folder yet, it will be created soon!
{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;strict\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true }, \u0026#34;include\u0026#34;: [\u0026#34;index.ts\u0026#34;, \u0026#34;lib/\u0026#34;] } Visit https://aka.ms/tsconfig.json to read more about this file!
Save the file. We could run the compiler from the command line but it\u0026rsquo;s easier to set it up as a npm script. Add the compile, dev, and start scripts as shown below. The script section of package.json should look like this.
/* package.json */ \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;compile\u0026#34;: \u0026#34;tsc\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;tsc --watch\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;node build/index.js\u0026#34; package.json should now closely mirror the below file.
{ \u0026#34;name\u0026#34;: \u0026#34;glimesh-chatbot\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Tutorial for creating a chatbot on Glimesh.tv\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;compile\u0026#34;: \u0026#34;tsc\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;tsc --watch\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;node build/index.js\u0026#34; }, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;git+https://github.com/aMytho/Glimesh-Chatbot.git\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;Mytho\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;bugs\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/aMytho/Glimesh-Chatbot/issues\u0026#34; }, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/aMytho/Glimesh-Chatbot#readme\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/ws\u0026#34;: \u0026#34;^8.2.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.4.4\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;ws\u0026#34;: \u0026#34;^8.2.3\u0026#34; } } This adds 3 scripts.
compile will compile all of the Typescript to Javascript once. dev will compile all the code and recompile files automatically as changes are saved. start will run our project. We have to compile the JS files first! Let\u0026rsquo;s compile the file and run it. Enter the below lines into the terminal one after the other.
npm run compile
npm run start
This should compile the file and then output Hello World to the console. We should also run our dev script and ensure that it works.
npm run dev
While its running modify index.ts as shown below. Save the file.
/* index.ts */ console.log(\u0026#34;Hello Glimesh\u0026#34;); The file will be recompiled when saved because the dev script is running. In a new terminal window run npm run start . This will run the compiled file.
It is common to have 2 terminal windows open. One runs the dev script in the background and the other is for manually runs your scripts. You can also use auto-reload tools such as nodemon.
Now that we have a proper dev env setup we can start to build our bot.
Authentication # All projects that use the Glimesh API require some form of authentication. Glimesh needs to know which project is making API requests. There are many different methods to authenticate our chatbot but we will use client credentials. We are using this method because we are the only people who will view our source code. It is also the easiest form of auth.
We will start by creating a module to handle all auth related code. Create a folder called lib. In this folder create a file called auth.ts. Fill it with the data shown below.
/* lib/auth.ts */ // File handles all auth functions. import {readFile} from \u0026#34;fs/promises\u0026#34; import {join} from \u0026#34;path\u0026#34; const axios:typeof import(\u0026#34;axios\u0026#34;).default = require(\u0026#39;axios\u0026#39;).default; console.log(\u0026#34;Auth Dependencies loaded!\u0026#34;); readFile is a function to read a specific file asynchronously. This will read our auth file when we create one. join is a function to combine file paths. This will help us to locate our auth file. axios is a library to make HTTP requests. We will send our auth information to Glimesh using this library.
Notice the error that shows up on the line that imports axios. This is because Axios is not installed by default. We need to add it to our dependencies. Run the below line in your terminal.
npm install axios
You can install any NPM library this way!
We also need a place to store our auth info (clientId / secretId). It is not wise to include your secretId in your source code. We will make a dedicated json file to store the auth info. We will also add a reference to it in the .gitignore file. This prevents it from being included in commit history.
If you want even more security you can do this through env variables instead of an auth.json file.
Create the files shown below in the root of the project.
auth.json
Replace your client ID and client secret as shown below. If you do not yet have a developer application you can get one here.
{ \u0026#34;clientId\u0026#34;: \u0026#34;YOUR ID HERE\u0026#34;, \u0026#34;secretId\u0026#34;: \u0026#34;YOUR SECRET ID HERE\u0026#34; } .gitignore
This may already be created. If so just add the lines to the bottom of the file. If not create the file. This prevents git from commiting our auth code and generated files.
# Ignore our credentials auth.json # Ignore our js built files build/ Now we need to import the auth info so we can send it to Glimesh. We will create a variable that mirrors the structure from the auth file. We also create a function to read the auth file and a function to request an access token from Glimesh. These will both be imported and called from index.ts. Add the below lines to the auth file.
/* lib/auth.ts */ async function readAuthInfo(): Promise\u0026lt;AuthFile | false\u0026gt; { try { const path = join(__dirname, \u0026#34;..\u0026#34;, \u0026#34;..\u0026#34;, \u0026#34;auth.json\u0026#34;); let data = await readFile(path); let authData = data.toString(); return JSON.parse(authData); } catch(e) { console.log(\u0026#34;Error getting auth info\u0026#34;, e); return false } } async function getAccessToken(client: string, secret: string) { try { const URL = \`https://glimesh.tv/api/oauth/token?grant_type=client_credentials\u0026amp;client_id=\${client}\u0026amp;client_secret=\${secret}\u0026amp;scope=chat public\`; let data = await axios.post(URL); let tokenInfo = data.data as ClientCredentialsResult; console.log(tokenInfo); return tokenInfo.access_token } catch (e) { console.log(e); return false } } interface AuthFile { clientId: string; secretId: string; } /** * Info from a client cred request. */ interface ClientCredentialsResult { access_token: string, created_at: string, expires_in: number, refresh_token: null, scope: string, token_type: string } export {getAccessToken, readAuthInfo} This is a lot of code! Let\u0026rsquo;s start with the first function readAuthInfo(). This is an async function so it returns a promise. It tries to read the auth file and then returns a JSON parsed version of the auth data. This lets us easily access the properties. This function will return false if anything goes wrong.
The next function getAccessToken() returns a Glimesh access token. It requires our client and secret ID to be passed to it as parameters. We send a HTTP POST request to Glimesh and wait for the result. If all goes well we will receive an access token.
Note the type defs on the bottom. These provide autocompletion for our data. They are removed at runtime.
Now we can import the functions and run them to get an access token. Add the lines to index.ts.
/* index.ts */ import { getAccessToken, readAuthInfo } from \u0026#34;./lib/auth\u0026#34;; let token = \u0026#34;\u0026#34;; async function authenticate() { let authInfo = await readAuthInfo(); if (authInfo) { let accessToken = await getAccessToken(authInfo.clientId, authInfo.secretId); return accessToken } } let waitForAuth = authenticate(); waitForAuth.then(data =\u0026gt; { console.log(data); // Make sure everything worked correctly. if (data \u0026amp;\u0026amp; typeof data == \u0026#34;string\u0026#34;) { token = data; } }) First we define a token variable. This will hold our access token when we receive it. Then we read the auth file and use it to request a token. When we receive the token we set our token variable equal to it. We can now connect to the API!
Connecting to Chat # We will create a function connectToGlimesh to connect to chat and add several listeners. We will also make a module for parsing data and a module for running commands. This helps to keep our code organized. Add the following lines to the top of index.ts.
/* Top of index.ts */ import WebSocket from \u0026#34;ws\u0026#34; /* index.ts */ async function connectToGlimesh(token: string) { console.log(\u0026#34;Trying to connect to the Glimesh API.\u0026#34;); let connection = new WebSocket(\`wss://glimesh.tv/api/socket/websocket?vsn=2.0.0\u0026amp;token=\${token}\`); // Add listeners. connection.on(\u0026#34;open\u0026#34;, (data: any) =\u0026gt; { console.log(\u0026#34;Connected to Glimesh.\u0026#34;); // Connect to phoenix websocket connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}]\u0026#39;); // Join a chat and listen for messages connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ chatMessage(channelId: 6) { user { username avatarUrl } message } }\u0026#34;,\u0026#34;variables\u0026#34;:{} }]\u0026#39;); // Send a heartbeat every 30 sec so glimesh knows we still exist setInterval(() =\u0026gt; { connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;heartbeat\u0026#34;,{}]\u0026#39;); }, 30000) }) connection.on(\u0026#34;close\u0026#34;, (closure:any) =\u0026gt; { console.log(\`Connection was closed.\`); console.log(closure); }) connection.on(\u0026#34;error\u0026#34;, (err:any) =\u0026gt; { console.log(\u0026#34;Connection encountered an error! This will likely disconnect and fire the close event.\u0026#34;); console.log(err); }) connection.on(\u0026#34;message\u0026#34;, (data: Buffer) =\u0026gt; { console.log(data.toString()); }) } This function needs to run once we receive our token. Call the function below the token = data line. The waitForAuth callback function should look like the code below.
/* index.ts */ waitForAuth.then(data =\u0026gt; { console.log(data); // Make sure everything worked correctly. if (data \u0026amp;\u0026amp; typeof data == \u0026#34;string\u0026#34;) { token = data; // Now that we have a token we can connect to chat! connectToGlimesh(token); } }) The function connectToGlimesh will connect us to the Glimesh websocket server. Once connected we add event listeners to the connection variable. They will run whenever the specified event occurs. When the connection is completed we send a few packets to the server.
Connects to the internal Phoenix endpoint.
connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;phx_join\u0026#34;,{}]\u0026#39;); Connects to a channel with a specified ID. (We will explain this later). Subscribes to new chat messages and asks for the message and the user\u0026rsquo;s name and avatar.
connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;__absinthe__:control\u0026#34;,\u0026#34;doc\u0026#34;,{\u0026#34;query\u0026#34;:\u0026#34;subscription{ chatMessage(channelId: 6) { user { username avatar } message } }\u0026#34;,\u0026#34;variables\u0026#34;:{} }]\u0026#39;); Sends a heartbeat to Glimesh every 30 seconds. This let\u0026rsquo;s Glimesh know your connection still exists.
setInterval(() =\u0026gt; { connection.send(\u0026#39;[\u0026#34;1\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;phoenix\u0026#34;,\u0026#34;heartbeat\u0026#34;,{}]\u0026#39;); }, 30000) This will complete the chat connection and send us chat messages on the specified ID. If you know your channel ID you can add it to the above code replacing 6 with your ID. If you do not know your ID you can head to /API and make the below query in the editor replacing Mytho with your channel. It will return the ID of your channel.
query { channel(username: \u0026#34;Mytho\u0026#34;) { id } } You don\u0026rsquo;t need any special permission to listen for chat messages. Any access token or client ID can listen to any channel. Once you complete this tutorial have a look at listening to every channel at once.
Save and run the file. It should connect to chat and listen for messages. Try sending one! It will also send you a heartbeat every 30 seconds.
Make sure the file is compiled before you run it!
Handling Incoming Data # Now that we have messages we need to parse the incoming data and make it check for commands. Create the 2 files shown below.
Responsible for handling all data from Glimesh (not just chatMessages) lib/packet.ts
Responsible for scanning messages and running commands. lib/command.ts
Add the below code to lib/packet.ts
/* lib/packet.ts */ function parsePacket(packet: any) { if (packet[1] == 1) { // Its the connection response, do nothing. return false } else if (packet[1] == 2) { // Glimesh confirming our chat message subscription. return false } else if (packet[1] == 3) { // Its a heartbeat. We can ignore it. return false } else if (packet[1] == 4) { // Its a response to a message we sent. We don\u0026#39;t respond to those. return false } else { // Its a chat message! return packet[4].result.data.chatMessage.message } } export {parsePacket} This creates a function to parse the data from Glimesh. We only return data if the packet is a chatmessage. This ignores heartbeats and all other data. If you want to add the ability to make queries from the websocket you would need to modify this function or use the same first 2 values as the chatMessage query. We will not be covering that in this doc.
Handling Commands # We also need to add the code to handle commands. Add the following to lib/command.ts
/* lib/command.ts */ function checkForCommand(message: string): string | false { let firstWord = message.split(\u0026#34; \u0026#34;)[0]; for (let i=0; i \u0026lt; Commands.length; i++) { if (Commands[i].cmdName == firstWord) { return Commands[i].cmdMessage; } } return false } const Commands:Command[] = [ { cmdName: \u0026#34;!example\u0026#34;, cmdMessage: \u0026#34;Hello World!\u0026#34; } ] type Command = { cmdName: string; cmdMessage: string } export { checkForCommand } This file adds a few things. We define a Command type. This provides type safety and handy autocompletion. We also create the Commands variable. This holds all of our commands. In our case we added the command example. Feel free to add as many commands as you want in the above format. We also define a function to scan for the command and return the message if it finds a match.
Although adding commands in the code is fine for this example in a real scenario you would want some sort of data storage. A JSON file or small database would work well.
We need to run the function we created in the last 2 files. Import them at the top of index.ts
import { checkForCommand } from \u0026#34;./lib/command\u0026#34;; import { parsePacket } from \u0026#34;./lib/packet\u0026#34;; Call them in the websocket message handler function. It should look like the code below.
/* index.ts */ connection.on(\u0026#34;message\u0026#34;, (data: any) =\u0026gt; { let glimeshData = data.toString(); console.log(glimeshData.toString()); let message = parsePacket(JSON.parse(glimeshData)); if (message) { let command = checkForCommand(message); if (command) { sendMessage(command); } } }) This checks for a message and if it exists it checks for a command. If the command exists the command message is returned. We need to make the sendMessage function so we can talk to chat. Add the following function just below the message handler function. (It must be within the connectToGlimesh function. Replace 6 with your channel ID.
function sendMessage(message: string) { let query = \`mutation {createChatMessage(channelId: 6, message: {message: \u0026#34;\${message}\u0026#34;}) { message }}\` let packet = [ \u0026#34;1\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;__absinthe__:control\u0026#34;, \u0026#34;doc\u0026#34;, { query: query, variables: {} } ] console.log(JSON.stringify(packet)) connection.send(JSON.stringify(packet)) } Now we call this function if a command is triggered. Whenever a command is triggered the message of the command is sent back to chat.
Congratulations! You now have a fully functioning chatbot. You can continue to add commands in the format shown.
What next?
Add a dedicated database to store commands. Small databases such as NEDB and SQLite work well for this. You would need to add a way to programmatically add and edit commands in the database. Add modules for storing user data (watch time, points, etc). Add a web panel to modify and monitor the bot (advanced).
Questions?
Ask your questions in the dev-questions channel in discord. We will try to help with any issue provided the project is Glimesh related.
`}),e.add({id:21,href:"/api-docs/docs/developerresources/libraries/",title:"Libraries",section:"Developer Resources",content:` Community Libraries # This is a list of community created libraries to help communicate with the API. All of these libraries are community made and not official in any way.
NodeJS/TypeScript # https://www.npmjs.com/package/glimesh-chat
A library for connecting to chat and using moderator actions such as timeouts and bans.
An access token is required to use this module.
Created by Innectic
C# # https://www.nuget.org/packages/StreamingClientLibrary.Glimesh/
A library for connecting to the Glimesh chat API in C#.
This library has other functions for subscriptions and queries.
Created by SaviorXTanren
Java # https://github.com/Casterlabs/GlimeshApiJava
A library for interacting with the Glimesh api.
This library provides realtime connections for followers, chat, and channel. It also provides api query request helpers with POJO responses.
Created by Casterlabs
`}),e.add({id:22,href:"/api-docs/docs/developerresources/tools/",title:"Tools",section:"Developer Resources",content:` Community Libraries # This is a list of tools to help develop apps with the API. None of these are required but they may help you during development.
Insomnia # https://insomnia.rest
A tool for working with GraphQL APIs. This allows you to view all of the data and make queries. We have a tutorial for using it here.
`}),e.add({id:23,href:"/api-docs/docs/reference/api/",title:"API",section:"Reference",content:` API Requests # This document shows common API requests that may be of use. To see the most recent version of the API use an API explorer or view Voyager
Remove any comments before sending to Glimesh.
Category List # Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.
{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } } `}),e.add({id:24,href:"/api-docs/docs/reference/apireference/",title:"API Reference",section:"Reference",content:`Remove any comments before sending to Glimesh.
Category List # Returns a list of all the categories. Query query { categories { id, # ID of the category name, # Name of the category slug, # Slug of the category (lowercase name) tagName, # The parent and current category: Art \u0026gt; Digital parent { # The parent category. Null if no parent exists. name # all of the above fields are available } } } Response This shows two of the categories returned.
{ \u0026#34;data\u0026#34;: { \u0026#34;categories\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Gaming\u0026#34;, \u0026#34;parent\u0026#34;: null, \u0026#34;slug\u0026#34;: \u0026#34;gaming\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Gaming\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Digital\u0026#34;, \u0026#34;parent\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Art\u0026#34; }, \u0026#34;slug\u0026#34;: \u0026#34;digital\u0026#34;, \u0026#34;tagName\u0026#34;: \u0026#34;Art \u0026gt; Digital\u0026#34; }, ] } } `}),e.add({id:25,href:"/api-docs/docs/reference/channel/",title:"Channel",section:"Reference",content:` Channel Subscription # Shows all the properties of the channel object. Note that for nested objects only one propery is shown.
subscription { channel(id: 6) { bans(last: 3) { edges { node { reason } } } blockLinks category { name } chatBgUrl chatRulesHtml chatMessages(last: 3) { edges { node { message } } } chatRulesMd disableHyperlinks hmacKey id inaccessible insertedAt language matureContent minimumAccountAge moderationLogs { edges { node { action } } } moderators { edges { node { canBan } } } posterUrl requireConfirmedEmail showOnHomepage showRecentChatMessagesOnly status stream { id } streamKey streamer { username } streams { edges { node { countViewers } } } subcategory { name } tags { name } title updatedAt } } A full list of every property can be found in a GraphQL editor. An interactive version of the API can be found on our voyager page.
`}),e.add({id:26,href:"/api-docs/docs/reference/channelreference/",title:"Channel Reference",section:"Reference",content:`Shows all the properties of the channel object. Note that for nested objects only one propery is shown.
subscription { channel(id: 6) { bans(last: 3) { edges { node { reason } } } blockLinks category { name } chatBgUrl chatRulesHtml chatMessages(last: 3) { edges { node { message } } } chatRulesMd disableHyperlinks hmacKey id inaccessible insertedAt language matureContent minimumAccountAge moderationLogs { edges { node { action } } } moderators { edges { node { canBan } } } posterUrl requireConfirmedEmail showOnHomepage showRecentChatMessagesOnly status stream { id } streamKey streamer { username } streams { edges { node { countViewers } } } subcategory { name } tags { name } title updatedAt } } `}),e.add({id:27,href:"/api-docs/docs/reference/chat/",title:"Chat",section:"Reference",content:` Chat # Shows all of the fields in the chatMessage object.
chatMessage { id, insertedAt, message, updatedAt, isSubscriptionMessage, isFollowedMessage, channel { // Channel data }, metadata { // Metadata about the user at the time of the message (is sub/mod/founder/etc) } user { // User data } } `}),e.add({id:28,href:"/api-docs/docs/reference/chatparts/",title:"Chat Parts",section:"Reference",content:` Chat Parts # All the possbile data to query from a chat part.
subscription{ chatMessage(channelId:6) { message, user { id }, tokens { text, type, ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } A possible response. (Dependent on query and message)
[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, }, { \u0026#34;text\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34; }, ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ] `}),e.add({id:29,href:"/api-docs/docs/reference/chatpartsreference/",title:"Chat Parts Reference",section:"Reference",content:`All the possbile data to query from a chat part.
subscription{ chatMessage(channelId:6) { message, user { id }, tokens { text, type, ...on EmoteToken { src, text, type, }, ...on TextToken { text, type }, ...on UrlToken { text, type, url } } } } A possible response. (Dependent on query and message)
[ null, null, \u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34;, \u0026#34;subscription:data\u0026#34;, { \u0026#34;result\u0026#34;:{ \u0026#34;data\u0026#34;:{ \u0026#34;chatMessage\u0026#34;:{ \u0026#34;tokens\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Hello Glimesh Devs \u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;/emotes/svg/glimsmile.svg\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;:glimsmile:\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;emote\u0026#34;, }, { \u0026#34;text\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://glimesh.tv\u0026#34; }, ] } } }, \u0026#34;subscriptionId\u0026#34;:\u0026#34;__absinthe__:doc:-576460752302054414:1C57C19163D4D59F61626243BCCA79AB4E50D5C4C2BD8BDA0DDCE83517B20C16\u0026#34; } ] `}),e.add({id:30,href:"/api-docs/docs/reference/chatreference/",title:"Chat Reference",section:"Reference",content:`Shows all of the fields in the chatMessage object.
chatMessage { id, insertedAt, message, updatedAt, isSubscriptionMessage, isFollowedMessage, channel { // Channel data }, metadata { // Metadata about the user at the time of the message (is sub/mod/founder/etc) } user { // User data } } `}),e.add({id:31,href:"/api-docs/docs/reference/mod/",title:"Mod",section:"Reference",content:` Mod Reference # Shows all the queries related to moderation. Note that for nested properties only one property is shown.
Short and long timeouts have the same properties.
mutation { shortTimeoutUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Banning and unbanning a user have the same properties.
mutation { banUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Deletes a message.
mutation { deleteChatMessage(channelId:6, messageId: 999) { action, channel {id}, insertedAt, moderator { displayname }, updatedAt, user { displayname } } } Shows all of the properties for a moderation log.
query { channel(id: 6) { moderationLogs { edges { node { action channel { id } insertedAt moderator { username } updatedAt user { username } } } } } } A full list of every property can be found in a GraphQL editor. An interactive version of the API can be found on our voyager page.
`}),e.add({id:32,href:"/api-docs/docs/reference/modreference/",title:"Mod Reference",section:"Reference",content:`Shows all the queries related to moderation. Note that for nested properties only one property is shown.
Short and long timeouts have the same properties.
mutation { shortTimeoutUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Banning and unbanning a user have the same properties.
mutation { banUser(channelId:6, userId:201) { action, channel {id}, insertedAt, moderator {displayname}, updatedAt, user {displayname} } } Deletes a message.
mutation { deleteChatMessage(channelId:6, messageId: 999) { action, channel {id}, insertedAt, moderator { displayname }, updatedAt, user { displayname } } } Shows all of the properties for a moderation log.
query { channel(id: 6) { moderationLogs { edges { node { action channel { id } insertedAt moderator { username } updatedAt user { username } } } } } } `}),e.add({id:33,href:"/api-docs/docs/reference/scopes/",title:"Scopes",section:"Reference",content:` Scopes # Scopes are permissions that a developer application requests from a client. The client must approve all of the scopes that you request. You should only request scopes that you plan to use. Below documents all of the available scopes.
public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. streamkey View the streamkey of the user. (This is a protected field. Even with the scope it is unable to be accessed by third party devs.) follow Follow and unfollow on behalf of the user. stream_info Change the title on behalf of the channel. (Will be expanded to cover more fields) More scopes will be added over time. Your users will have to manually approve the new scopes.
`}),e.add({id:34,href:"/api-docs/docs/reference/scopesreference/",title:"Scopes Reference",section:"Reference",content:" public: Get public information about the user and other users on Glimesh. email: View the email of the user. chat: View and speak in a chatroom. streamkey View the streamkey of the user. (This is a protected field. Even with the scope it is unable to be accessed by third party devs.) follow Follow and unfollow on behalf of the user. stream_info Change the title on behalf of the channel. (Will be expanded to cover more fields) "}),e.add({id:35,href:"/api-docs/docs/api/query-api/basic-query/",title:"Generic Query",section:"API Queries",content:` Glimesh API Requests # This is a basic tutorial for communicating with the Glimesh API. This guide assumes you have a client ID or an access token from a user. Having basic GraphQL knowledge would also be helpful.
New to GraphQL? This tutorial explains the basics. https://graphql.org/learn/schema/
Authentication # All requests made to Glimesh must contain the proper authentication. The authentication value should be included as a header of the request. This value will change depending on the authentication type. For access tokens use:
Authorization: Bearer YOUR_TOKEN
Replace YOUR_TOKEN with your access token. If you are using a client ID to authenticate you must use this instead:
Authorization: Client-ID YOUR_CLIENT_ID
Replace YOUR_CLIENT_ID with your ID. This will allow you access to the API.
A client ID can use the API in read only mode. An access token is limited by its scopes.
Building Our Request # The Glimesh API uses GraphQL. You must structure your query accordingly. Some data requires an access token with a special scope. For this example we will structure a basic request that requires no special scope. The query must be included in the body of the request.
query { user(username: \u0026#34;USERNAME\u0026#34;) { username id } } Make sure to change \u0026ldquo;USERNAME\u0026rdquo; to a user on Glimesh. We are requesting the username and ID of the user. Now that we have our authentication and our query we can request the data. Send a POST request with our query and header from above to:
https://glimesh.tv/api/graph Glimesh will send a JSON formatted response when it receives our request.
{ \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;154\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Mytho\u0026#34; } } } You can parse the response to get the data you want. You could test every query like this but there is an easier way.
API Explorer # You can use an API explorer to make queries without the need of a dev environment. API explorers let you run queries with intellisense and some even handle authentication for you.
We have a dedicated tutorial on using the Insomnia GraphQL editor here. We also provide a collection of common requests which can be found in that tutorial.
If you have any questions feel free to talk to us in Discord.
Common Errors # There are a few errors you may encounter while querying the API.
Error: 401 Unauthorized. You must be logged in to access the API.
This is an authentication issue. Check your authentication header. You need to use the right type of authentication and make sure that the information is valid.
Internal Server Error This is usually user error rather than a server error. Ensure the auth info is correct and check your query for errors. If you think your query is correct try it here.
syntax error before: \\\u0026quot;\\\\\\\u0026quot;QUERY\\\\\\\u0026quot;\\\u0026quot;\u0026quot; Your query is in the incorrect format. It must match the GraphQL specifications. You can only request properties that exist and you must have the proper permissions to access them. Check the API docs for more information.
Stuck with something? Talk to us in Discord. We would be happy to help you!
`}),e.add({id:36,href:"/api-docs/docs/api/glimesh-ids/",title:"Glimesh IDs",section:"API",content:` IDs # IDs are a unique identifier for data in the API. Each item of the same type will have its own ID. This can be used to separate it from other items. An ID will never change unlike other unique fields (username). IDs are auto-incremented which means that the higher the ID the newer the item is.
If you are confused about which ID to use simply look at what the query requires. All parameters can be found in the API Explorer.
Channel ID # A channel ID identifies a channel. It is used in channel related queries.
Streamer ID # A streamer ID is the same as a user ID. We use a different name to prevent confusion in certain queries (followers).
User ID # A user ID identifies a user. Used in user related queries.
`}),e.add({id:37,href:"/api-docs/docs/authentication/accesstoken/nodejs/node-access-token/",title:"NodeJS Access Token",section:"Access Token",content:` Getting User Tokens With NodeJS # This is a basic tutorial for getting an auth token from a user using Oauth with NodeJS. This guide assumes you know basic JS and understand the workings of Oauth 2.
Need a refresh? This tutorial explains the basics of Oauth 2 https://darutk.medium.com/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb
Creating the Project # We need to create a basic project. In your terminal type:
npm init -y
This will create a project.JSON file. This project uses the Express and Request packages. Install them with:
npm install express request
These packages will help us set up a basic web server and send requests to Glimesh.
Starting Up # In your project create a blank JS file. I will title mine auth.js. Start by importing Express. Paste this at the top of your file.
const express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private. var redirectUri = \u0026#34;http://localhost:3000/success\u0026#34;; //The redirect path you want to encode into the auth request This imports the modules our server will need. The server will use the app variable for creating endpoints. The IDs are used so Glimesh can identify our app. We will insert the IDs later.
Creating the server # First we need to tell the server to listen for connections. We also need to tell the server which port to be on. I would recommend 8080 or 3000. Paste this in your file:
const port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^ This will keep the server from closing by itself. Now we can create endpoints for our users to connect to. One will redirect to the Glimesh auth page (/oauth/authorize) and the other will handle the auth info sent from Glimesh. You can create a web page for the first endpoint if you wish. For the sake of this tutorial I will keep it a simple redirect. Paste this in your file:
//When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page res.redirect(307, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=\u0026#39; + encodeURIComponent(redirectUri)); }); In this URL we send the client ID, the redirect URL, and a set of scopes that we want access to. We also request a code in the response_type. Next we will create a developer application. This will give us a client ID and a secret ID.
If you have a web page that you want your users to access when they go to this endpoint you can send it to them by using res.sendFile(\u0026quot;FILE_NAME.html\u0026quot;) You would need to have a button or other method to send them to the authentication page.
Developer Applications # Before we can request Oauth permissions we need a developer application. This is what Glimesh will use to authenticate users for your app. It is also how Glimesh can monitor and identify requests you and your users send. Click here to create your developer application.
Set up your dev application like this. Use a unique name and description. You can update these at any time. Ensure that the homepage of your app is http://localhost:3000 and your redirect link is http://localhost:3000/success. You must replace the port number if you used a different port.
Save your app when you are finished.
Getting the Token # Now that we have a developer app we can update our variables. Set it equal to your client ID and secret ID. It is very important to keep the secret ID hidden from your users. If your ID is leaked you can reset them from the Glimesh dev app page but your users must authenticate again.
var clientID = \u0026#34;CLIENT_ID_HERE\u0026#34; var secretID = \u0026#34;SECRET_HERE\u0026#34; We need to create an endpoint for Glimesh to redirect to. In the previous section we told Glimesh to redirect to locahhost:3000/success. Let\u0026rsquo;s create it!
app.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(\`\u0026lt;h1\u0026gt;code recieved!\u0026lt;/h1\u0026gt;\`) //Sends a confirmation message to the user }); When our user is redirected to our server the token is sent in the URL as ?code=CODE_HERE. We pull the code from URL and log it to the console.
Once you have the code you can request the token from Glimesh. This can be done with a simple Request function. When we get a response we parse it and log it to the console. Update the code for the /success endpoint as follows:
app.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(\`\u0026lt;h1\u0026gt;Code recieved, requesting token!\u0026lt;/h1\u0026gt;\`) //Sends a confirm message to the user //Now we send this code to Glimesh to ask for a token. var options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=\u0026#34; + encodeURIComponent(redirectUri) + \u0026#34;\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be console.log(body); //The unfiltered response var data = JSON.parse(body); console.log(data) } else { console.log(error) //log any errors console.log(response.statusCode) console.log(body) } }); }); Save the file when you are finished. Let\u0026rsquo;s test our code! In your terminal type:
node FILE_NAME.js
Replace FILE_NAME with the name of your file. This will start up the web server. Some antivirus programs may block the process because other devices on your network can access this server. Simply allow the port number you used in your antivirus software if this is the case. You may want to restart the server.
Once that is complete and the server is running head to http://localhost:3000/auth replacing the port number with the correct port. It will redirect you to your client application page. Accept it and it will redirect you back to your server at the /success endpoint.
Please note that you must be logged in before authorizing. A bug prevents you from entering your account info and proceeding to the client app screen. If you are not logged in you must sign in and then go back to /auth
You should see a confirmation message in your browser. The server is now sending the code back to Glimesh to request a token. Check the console in your terminal to see the code!
You can use the access_token to query the API on the users behalf. This will expire in 24 hours so you will need to refresh the token or get a new one. If you have any question talk to us in the #dev-questions channel in our Discord. We would love to hear what you are making!
The full file can be found here.
const express = require(\u0026#39;express\u0026#39;); //Express package const app = express(); // Creates endpoints for the server. const request = require(\u0026#39;request\u0026#39;); //Request package var clientID = \u0026#34;\u0026#34;; // ID for connecting your users to your app. var secretID = \u0026#34;\u0026#34;; //ID to verify your app, keep private. var redirectUri = \u0026#34;http://localhost:3000/success\u0026#34;; //The redirect path you want to encode into the auth request const port = process.env.PORT || 3000; //Opens the server on port 3000 app.listen(port, () =\u0026gt; console.log(\u0026#39;App listening on port \u0026#39; + port)); //keeps the server running^ //When a user visits http://localhost:3000/auth app.get(\u0026#39;/auth\u0026#39;, (req, res) =\u0026gt; { //redirects the user to the glimesh authenication page res.redirect(307, \u0026#39;https://glimesh.tv/oauth/authorize?response_type=code\u0026amp;state=\u0026amp;client_id=\u0026#39; + clientID + \u0026#39;\u0026amp;scope=public%20email%20chat%20streamkey\u0026amp;redirect_uri=\u0026#39; + encodeURIComponent(redirectUri)); }); app.get(\u0026#34;/success\u0026#34;, (req, res) =\u0026gt; { let code = req.query.code; console.log(\u0026#34;The code is \u0026#34; + code); res.send(\`\u0026lt;h1\u0026gt;Code Recieved!\u0026lt;/h1\u0026gt;\`) //Sends a confirm message to the user //Now we send this code to Glimesh to ask for a token. var options = { method: \u0026#39;POST\u0026#39;, body: \u0026#34;\u0026#34;, url: \u0026#34;https://glimesh.tv/api/oauth/token?grant_type=authorization_code\u0026amp;code=\u0026#34; + code + \u0026#34;\u0026amp;redirect_uri=\u0026#34; + encodeURIComponent(redirectUri) + \u0026#34;\u0026amp;client_id=\u0026#34; + clientID + \u0026#34;\u0026amp;client_secret=\u0026#34; + secretID }; request(options, (error, response, body) =\u0026gt; { //Send glimesh the code for a token in return if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //If all is as it should be console.log(body); //The unfiltered response var data = JSON.parse(body); //The parsed response console.log(data) // The data we want! } else { console.log(error) //log any errors console.log(response.statusCode) //Status code if an error occurs console.log(body) //The body for more info } }); }); `}),e.add({id:38,href:"/api-docs/docs/api/query-api/nodejs/node-query/",title:"NodeJS Query",section:"API Queries",content:" Glimesh API Requests With NodeJS # This is a basic tutorial for communicating with the Glimesh API using NodeJS. This guide assumes you know basic JS and have an access token from a user. You can use a client ID if you do not yet have a token. Having basic GraphQL knowledge would also be helpful.\nNeed a refresh? This tutorial explains the basics of graphql. https://graphql.org/learn/schema/\nCreating the Project # We need to create a basic project. In your terminal type\nnpm init -y .\nThis will create a project.JSON file. This project uses the Request npm package. It helps with sending requests to the server and handling the response. In your terminal type\nnpm install request.\nThat is the only package that you will need!\nStarting Up # In your project create a blank JS file. I will title mine \u0026ldquo;glimesh.js\u0026rdquo;. Start by importing the Request library. Paste this at the top of your file.\nvar request = require(\u0026#39;request\u0026#39;); Now we need to build our query. In this example we will ask Glimesh for the name and ID of our user. If you are using an access token you can get this data in the myself object. query{ myself { username, id } } However, we need to convert this so JS can understand it. To do this we create a data variable. Paste this under the import statement above.\nvar data = ` query { myself { username, id} } ` If you are going to use a client ID you have to specify which user to get data for. This is because a client ID does not have a user identity. This query will return the same data as the myself object.\nvar data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} } ` Feel free to replace USERNAME with your own username! Since we are not accessing any private information we do not need any special permissions/scopes.\nLeave the quotations around \u0026quot;USERNAME\u0026quot;. Glimesh processes our query as graphQL. Even though data is a string Glimesh will convert it to graphQL when it receives our request. GraphQL requires that the user we search for be a string. Since we used `` to encase the contents of data, quotations must be used to keep your username a string.\nDefine Options # Next we set up the call to the API. We need to add our data variable from above and our authentication as a header. We do this with the options variable. If you do not already have an authentication method (Client ID or Access Token) you need to get one now. Paste this below your query.\nvar options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api/graph\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Your_Token\u0026#39; } }; Notice we are sending the data variable from before. If you are using an access token replace \u0026ldquo;Your_Token\u0026rdquo; with your access token in the Authorization string. It should look like this. 'Authorization': 'Bearer qertyuiop123456789'\nIf you are using a client ID replace \u0026ldquo;Bearer\u0026rdquo; with \u0026ldquo;Client-ID\u0026rdquo; and \u0026ldquo;Your_Token\u0026rdquo; with your client ID. It should look like this.\n'Authorization': 'Client-ID qwertyuiop123456789'\nSend Request # Now we set up the request. We ask Glimesh for data and we setup a callback function to handle it when it arrives. The server will normally respond in less than one second. Paste this below the options variable.\nfunction callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { //if all works as it should... console.log(body); //The unfiltered response var convertedResponse = JSON.parse(body); //Convert the response so we can use it console.log(`The user is ${convertedResponse.data.myself.username} and the ID is ${convertedResponse.data.myself.id}`); } else { console.log(error) //log any errors. console.log(body) //sometimes the body contains the error. } } If you searched for a user instead of myself you need to change the convertedResponse output to:\nconsole.log(`The user ${convertedResponse.data.user.username} has an ID of ${convertedResponse.data.user.id}`); Finally we send the request. At the bottom of the file add this line.\nrequest(options, callback); When you are ready, save the file and type the line below in your terminal to query the API!\nnode filename.js\nMake sure to replace \u0026ldquo;filename\u0026rdquo; with the name of your file! For example -\nnode glimesh.js\nCommon Errors # You must be logged in to access the API. Cause: The auth string is incorrect. Make sure the token is valid. They expire after a short period and a new token is needed. You should also check the auth string. It should look like this 'Authorization': 'Bearer qertyuiop123456789' or 'Authorization': 'Client-ID qertyuiop123456789' depending on the auth method you used.\nInternal Server Error Cause: This is usually user error rather than a server error. Ensure the auth info is correct and check your query. The query is a string but the contents of that variable are graphQL. If you think your query is correct try it in a graphql explorer. Don\u0026rsquo;t forget to remove the `` when testing in an editor! Note that you must be signed in to use the API website!\nsyntax error before: \\\u0026quot;\\\\\\\u0026quot;query\\\\\\\u0026quot;\\\u0026quot;\u0026quot; Cause: Your query is in the incorrect format. Ensure it matches the example in the code above. You can only request properties that exist and you must have the proper permissions to access them.\nConclusion # This is the basis for most API requests. If you have any questions let us know in the #dev-questions channel in our Discord.\nThe full file can be found here.\nvar request = require(\u0026#39;request\u0026#39;); //Import the library //Define the data we want from Glimesh. var data = ` query { myself { username, id} } ` // If you used a client ID the myself object will not exist. Try this: /* var data = ` query { user (username: \u0026#34;USERNAME\u0026#34;){ username, id} }` */ //Make sure to replace USERNAME with a user! //Tell the request library where to send the request and how to add auth var options = { method: \u0026#39;POST\u0026#39;, body: data, url: \u0026#39;https://glimesh.tv/api/graph\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer Token_Here\u0026#39; //If you are using a client ID use \u0026#39;Authorization\u0026#39;: \u0026#39;Client-ID qwertyuiop123456789\u0026#39; } }; //Callback function runs when the data is recieved. We convert it to an object on arrival. function callback(error, response, body) { if (!error \u0026amp;\u0026amp; response.statusCode == 200) { console.log(body); //The unfiltered response var convertedResponse = JSON.parse(body); //Convert the response console.log(`You are ${convertedResponse.data.myself.username} and your ID is ${convertedResponse.data.myself.id}`); // If you are using a client ID you will have requested the user object. Use the line below instead! // console.log(`The user ${convertedResponse.data.user.username} has an ID of ${convertedResponse.data.user.id}`); } else { console.log(error); //log any errors console.log(body); } } //send the request request(options, callback); "}),e.add({id:39,href:"/api-docs/docs/api/stream/updatestreaminfo/",title:"Update Stream Info",section:"Stream Settings",content:` Update Stream Info # Using the new stream_info scope we can modify the title of a stream using the Glimesh API. While this scope currently contains 1 mutation, it will be expanded to cover the rest of the stream info fields.
Before beginning this tutorial you should have a working dev environment and understand the basics of the API.
Getting Permission # This mutation requires the stream_info scope. Any OAuth flow that uses an access token is valid for this query. Simply add the scope to the request:
scope=stream_info If you don\u0026rsquo;t understand the above explanation take a look at Auth Explained. You will need to choose a method of authentication that uses an access token. Set up the request and add the scope. Contact us on Discord if you need help!
Making the Mutation # Each action requires a slightly different mutation. Currently title is the only supported parameter. All mutations require the channel ID to target.
Updating the Title # You can request any channel info from the mutation. Here we request the updated title and the channel ID. Make the below query
mutation { updateStreamInfo(channelId: 6, title: \u0026#34;Updated from the API, wow, much amaze!\u0026#34;) { title, id } } Note that you cannot make a title longer than 255 characters. Additionally, entering a blank or invalid string will reset the title to its default state (Live Stream!).
`})})()